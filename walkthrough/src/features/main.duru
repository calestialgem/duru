// Showcases the features of the Duru Programming Language.
// Copyright (C) 2023 Cem Ge√ßgel <gecgelcem@outlook.com>

// Above is a line comment, like this one.

/*
 * This is a block comment.
 * /*
 *  * Which can be nested.
 *  */
 */





// =============================================================================
//                            D E C L A R A T I O N S
// =============================================================================

// All declarations can be prefixed with `public` keyword to make them visible
// from other packages. Another modifier is the `extern` keyword, which always
// must be fallowed with a string constant. That string constant will be the
// external name of the symbol as it will be represented in a C header or
// binary.



// `using` keyword declares an alias.
// ----------------------------------

/*
 * Declares `Integer` which is an alias for `duru::Integer_32`.
 */
using Integer = duru::Integer_32;

// If the name is omitted, it is the same as the aliased symbol's name.

/*
 * Declares `Float_32`, which is an alias for `duru::Float_32`.
 */
using duru::Float_32;



// `struct` keyword declares a product type.
// -----------------------------------------

// Members are listed comma-separated in `{}`.

/*
 * Declares `Person_Info` as a product type, which holds an `Integer` named
 * `age`, and a `Float_32` named `height`.
 */
struct Person_Info { age Integer, height Float_32 }



// `const` keyword declares a constant.
// ------------------------------------

// Value is specified after `=`.

/*
 * Declares `PI`, which is a constant of type `Float_32` and value `3.14`.
 */
const PI Float_32 = 3.14;



// `var` keyword declares a variable.
// ----------------------------------

// Initial value is specified after `=`.

/*
 * Declares `count`, which is a global variable of type `Integer` and initial
 * value `0`.
 *
 * Initial values must be known in compile-time, otherwise the declaration order
 * would be meaningful and the values of globals when the program starts running
 * would be indeterministic between builds.
 */
var count Integer = 0;



// `fn` keyword declares a function.
// ---------------------------------

// Parameters are listed comma-separated in `()`.

/*
 * Declares `add`, which is a function that takes two `Integer`s and returns and
 * `Integer`.
 */
fn add(a Integer, b Integer) Integer { return a + b; }

// Function body can be omitted, which means it is a foreign interface that will
// be provided foreign code.

/*
 * Declares `print_string`, which is a function that takes a pointer to
 * `duru::Byte` and returns an `Integer`. Its definition is provided by a
 * foreign binary, and its name is `puts` there.
 *
 * This refers to the `puts` function that is provided by the C Standard
 * Library.
 */
extern "puts" fn print_string(string *duru::Byte) Integer;

// For functions that does not return anything, the `duru::Void` type should be
// used as the return type.

/*
 * Declares `do_it`, which is a function that does not take or return anything.
 */
fn do_it() duru::Void {}

// For functions that never return, the `duru::Noreturn` type should be used as
// the return type.

/*
 * Declares `exit`, which is a function that takes an `Integer` and does not
 * return. Its definition is provided by a foreign binary and its name is
 * `exit` there.
 *
 * This refers to the `exit` function that is provided by the C Standard
 * Library.
 */
extern "exit" fn exit(code Integer) duru::Noreturn;





// =============================================================================
//                              S T A T E M E N T S
// =============================================================================

/*
 * The entrypoint to this package.
 *
 * Packages in Duru are of 3 variants:
 * - Library packages are visible outside the module and facilitate code reuse.
 * They can be compiled to static libraries to be used by foreign code. (In that
 * case, probably the library would have public symbols with external names so
 * that foreign code can actually access these symbols.)
 * - Executable packages get compiled to executable binaries, and must declare
 * an entrypoint, which is a function that takes nothing and returns nothing.
 * Taking arguments from the command line and returning an exit code are done
 * using the functions in `duru` package if the target platform has them.
 * - Implementation packages are all remaining packages. They are not visible
 * outside of the module they are declared in, but also they do not have an
 * entrypoint. These are like library packages; however, they are only usable by
 * the packages in the same module.
 */
fn main() duru::Void {



  // Declare Statement
  // -----------------

  // Declare statements create a new variable similar to how it is done outside
  // the function body. The difference between locals and globals are that:
  // - locals have declaration order,
  // - cannot be used before they are declared,
  // - can have initial values that are unknown in compile-time,
  // - they have lexical scopes,
  // - cannot be used outside the scope they are declared in.
  // - can shadow (have the same name as) global symbols,
  var variable Integer = add(67, 17 * 58);



  // Affect Statement
  // ----------------

  // Affect statements are only executed for their side-effects. They mutate a
  // variable or call a function.

  // Discard statements evaluate an expression, but do not use the result.
  do_it();

  // Mutate statements change a variable's value using a trailing `++` or `--`.
  variable++; // add 1
  variable--; // subtract 1

  // Assign statements override a variable's value using a `=` and a value.
  variable = 90; // assign 90

  // The assignment can be compounded with an arithmetic binary operator to do
  // the binary operation on the assignee's previous value.
  variable  *= 10; // multiplies by 10
  variable  /= 10; // assigns the quotient of division by 10
  variable  %= 10; // assigns the reminder of division by 10
  variable  += 10; // adds 10
  variable  -= 10; // subtracts 10
  variable <<= 10; // shifts its bits to left by 10
  variable >>= 10; // shifts its bits to right by 10
  variable  &= 10; // ANDs its bits with bits of 10
  variable  ^= 10; // XORs its bits with bits of 10
  variable  |= 10; // ORs its bits with bits of 10



  // Block Statement
  // ---------------

  // Block statements group zero or more statements together and create a
  // lexical scope which restricts the locals.
  {
    17 + 58;
    var a Integer = 17 + 58;
    { var some_local Integer = 5; }
    { var some_local Integer = 5; }
    { { { { { { { { {} } } } } } } } }
  }



  // If Statement
  // ------------

  // If statements branch the control flow depending on a condition. The `if`
  // branch is taken if the condition is not zero, otherwise the `else` branch
  // is taken.
  if (variable < 58) { variable *= 2; }
  else { variable -= 5; }

  // The `else` branch can be omitted, which is the same as it having an empty
  // block as the body.
  if (17 < variable) { variable <<= 2; }

  // Local variables can be declared before the condition.
  if (var a Integer = variable * 2; a < 17) { variable += a; }
  else { variable -= a; }



  // For Statement
  // -------------

  // For statements loop the control flow depending on a condition. In the first
  // iteration, the `for` branch is taken if the condition is not zero,
  // otherwise the `else` branch is taken. After the `for` branch is taken once,
  // it is taken many times until the condition is revaluated to zero.
  {
    var sum Integer = 0;
    var n   Integer = 1;
    for (n <= 10) { n++; sum += n; }
    else { sum = -1; }
  }

  // The `else` branch can be omitted, which is the same as it having an empty
  // block as the body.
  {
    var pre_leading Integer = 0;
    var leading     Integer = 1;
    var fib         Integer = 1;
    var n           Integer = 1;
    for (n <= 10) {
      n++;
      pre_leading = leading;
      leading     = fib;
      fib        += pre_leading;
    }
  }

  // An affect statement trailing the loop condition can be provided, which will
  // be executed between iterations.
  var fib Integer = 0;
  {
    fib = 1;
    var pre_leading Integer = 0;
    var leading     Integer = 1;
    var n           Integer = 1;
    for (n <= 10; n++) {
      pre_leading = leading;
      leading     = fib;
      fib        += pre_leading;
    }
  }

  // Local variables can be declared before the condition.
  fib = 1;
  for (
    var pre_leading Integer = 0;
    var leading     Integer = 1;
    var n           Integer = 1;
    n <= 10; n++)
  {
    pre_leading = leading;
    leading     = fib;
    fib        += pre_leading;
  }



  // Break Statement
  // ---------------

  // Used for jumping out of a loop before it terminates by its condition.
  for (var i Integer = 0; i < 10; i++) {
    if (i == 5) { break; }
  }

  // Takes a label to specify which loop to break.
  {
    var sum     Integer = 0;
    var max_sum Integer = 17;
    combinations: for(var i Integer = 0; i < 10; i++) {
      for(var j Integer = i + 1; j < 10; j++) {
        var combination Integer = i * 10 + j;
        if (sum > max_sum - combination) { break combinations; }
        sum += combination;
      }
    }
  }



  // Continue Statement
  // ------------------

  // Used for jumping back to a loop condition before it executes all statements
  // in the body.
  {
    var odds Integer = 0;
    for (var i Integer = 0; i < 10; i++) {
      if (i % 2 == 0) { continue; }
      odds += i;
    }
  }

  // Takes a label to specify which loop to continue.
  {
    var black_squares Integer = 0;
    horizontal: for(var x Integer = 0; x < 10; x++) {
      vertical: for(var y Integer = 0; y < 10; y++) {
        if (is_even(x + y)) { continue horizontal; }
        black_squares++;
      }
    }
  }

  // Return Statement
  // ----------------

  // Terminates a function.
  return;
}

// Functions with return type `duru::Void` can reach to the end without a return
// statement. Such functions terminate as if there was an invisible return
// statement at the end.
fn does_not_return() duru::Void {}

fn is_even(num Integer) duru::Boolean {
  // Functions that a non-`duru::Void` return type must have a return statement
  // terminating all control paths. Furthermore, these return statements must
  // have a value, which will be the value seen by the function's caller.
  return num % 2 == 0;
}





// =============================================================================
//                             E X P R E S S I O N S
// =============================================================================

// Constructs that denote a value when evaluated. All expressions have a type
// that must be known in compile-time, which is the type of the value denoted by
// it. Some expressions denote values that are known in compile-time.



// Constants
// ---------

var string_constant *duru::Byte      = "Hello, Artisan!";
var number_constant duru::Integer_32 = 1919;



// Compound
// --------

fn a_function() duru::Void {
  var function_call  duru::Boolean    = is_even(15);
  var infix_call     duru::Boolean    = 15:is_even();
  var grouping       duru::Integer_32 = (56 + 5);
  var cast           duru::Float_32   = 10 as duru::Float_32;
  var initialization Person_Info      = Person_Info{age = 5, height = 56};
  var member_access  duru::Float_32   = initialization.height;
}



// Arithmetic Operations
// ---------------------

var promotion      duru::Integer_32 = +5;
var negation       duru::Integer_32 = -5;

var multiplication duru::Integer_32 = 5 * 5;
var quotient       duru::Integer_32 = 5 / 5;
var reminder       duru::Integer_32 = 5 % 5;

var addition       duru::Integer_32 = 5 + 5;
var subtraction    duru::Integer_32 = 5 - 5;



// Bitwise Operations
// ------------------

var bitwise_not duru::Natural_32 = ~5;

var shift_left  duru::Natural_32 = 5 << 5;
var shift_right duru::Natural_32 = 5 >> 5;

var bitwise_and duru::Natural_32 = 5  & 5;

var bitwise_xor duru::Natural_32 = 5  ^ 5;

var bitwise_or  duru::Natural_32 = 5  | 5;



// Comparison Operations
// ---------------------

var less_than                duru::Boolean = 5  < 5;
var less_than_or_equal_to    duru::Boolean = 5 <= 5;
var greater_than             duru::Boolean = 5  > 5;
var greater_than_or_equal_to duru::Boolean = 5 >= 5;

var equal_to                 duru::Boolean = 5 == 5;
var not_equal_to             duru::Boolean = 5 != 5;



// Logical Operations
// ------------------

var logical_not duru::Boolean = !0;

var logical_and duru::Boolean = 1 && 1;

var logical_or  duru::Boolean = 0 || 1;
