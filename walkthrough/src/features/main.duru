// Showcases the features of the Duru Programming Language.
// Copyright (C) 2023 Cem Ge√ßgel <gecgelcem@outlook.com>

// Above is a line comment, like this one.

/*
 * This is a block comment.
 * /*
 *  * Which can be nested.
 *  */
 */





// =============================================================================
//                            D E C L A R A T I O N S
// =============================================================================

// All declarations can be prefixed with `public` keyword to make them visible
// from other packages. Another modifier is the `extern` keyword, which always
// must be fallowed with a string constant. That string constant will be the
// external name of the symbol as it will be represented in a C header or
// binary.



// `using` keyword declares an alias.
// ----------------------------------

/*
 * Declares `int` which is an alias for `duru::int32`.
 */
using int = duru::int32;

// If the name is omitted, it is the same as the aliased symbol's name.

/*
 * Declares `float32`, which is an alias for `duru::float32`.
 */
using duru::float32;



// `struct` keyword declares a product type.
// -----------------------------------------

// Members are listed comma-separated in `{}`.

/*
 * Declares `person_info` as a product type, which holds an `int` named `age`,
 * and a `float32` named `height`.
 */
struct person_info { age int, height float32 }

// Incomplete types are specified using `;`.

/*
 * Declares `stream` as an incomplete type, which is only useful for defining
 * foreign interfaces with strongly typed pointers (instead of `void*`).
 */
extern "FILE" struct stream;



// `enum` keyword declares a sum type.
// -----------------------------------

// Alternatives are listed in `{}`.

/*
 * Declares `direction` as a sum type, which holds one of multiple other types:
 *  - `direction::aligned::east`
 *  - `direction::aligned::west`
 *  - `direction::aligned::north`
 *  - `direction::aligned::south`
 *  - `direction::unaligned`
 */
enum direction {
  enum aligned {
    struct east {}
    struct west {}
    struct north {}
    struct south {}
  }
  struct unaligned { x float32, y float32 }
}



// `fn` keyword declares a function.
// ---------------------------------

// Parameters are listed comma-separated in `()`.

/*
 * Declares `add`, which is a function that takes two `int`s and returns and
 * `int`.
 */
fn add(a int, b int) int { return a + b; }

// Function body can be omitted, which means it is a foreign interface that will
// be provided foreign code.

/*
 * Declares `print_string`, which is a function that takes a pointer to
 * `duru::byte` and returns an `int`. Its definition is provided by a foreign
 * binary, and its name is `puts` there.
 *
 * This refers to the `puts` function that is provided by the C Standard
 * Library.
 */
extern "puts" fn print_string(string *duru::byte) int;

// For functions that does not return anything, the `duru::void` type should be
// used as the return type.

/*
 * Declares `do_it`, which is a function that does not take or return anything.
 */
fn do_it() duru::void {}

// For functions that never return, the `duru::noreturn` type should be used as
// the return type.

/*
 * Declares `exit`, which is a function that takes an `int` and does not return.
 * Its definition is provided by a foreign binary and its name is `exit` there.
 *
 * This refers to the `exit` function that is provided by the C Standard
 * Library.
 */
extern "exit" fn exit(code int) duru::noreturn;



// `var` keyword declares a variable.
// ----------------------------------

// Initial value is specified after `=`.

/*
 * Declares `count`, which is a global variable of type `int` and initial value
 * `0`.
 *
 * Initial values must be known in compile-time, otherwise the declaration order
 * would be meaningful and the values of globals when the program starts running
 * would be indeterministic between builds.
 */
var count int = 0;

// Initial value can be omitted, which means it is a foreign variable that lives
// in a foreign binary.

/*
 * Declares `value`, which is a global variable of type `int` that is named as
 * `linking_error` in the resulting binary.
 *
 * It is named `linking_error` because there is no global defined by the
 * C Standard Library that can be showcased here. Since there is not an actual
 * variable anywhere in the foreign binary (we only link to C Standard Library
 * while compiling this), it would be a linking error to try storing to or
 * loading from this variable.
 */
extern "linking_error" var should_not_be_used int;





// =============================================================================
//                              S T A T E M E N T S
// =============================================================================

/*
 * The entrypoint to this package.
 *
 * Packages in Duru are of 3 variants:
 * - Library packages are visible outside the module and facilitate code reuse.
 * They can be compiled to static libraries to be used by foreign code. (In that
 * case, probably the library would have public symbols with external names so
 * that foreign code can actually access these symbols.)
 * - Executable packages get compiled to executable binaries, and must declare
 * an entrypoint, which is a function that takes nothing and returns nothing.
 * Taking arguments from the command line and returning an exit code are done
 * using the functions in `duru` package if the target platform has them.
 * - Implementation packages are all remaining packages. They are not visible
 * outside of the module they are declared in, but also they do not have an
 * entrypoint. These are like library packages; however, they are only usable by
 * the packages in the same module.
 */
fn main() duru::void {



  // Declare Statement
  // -----------------

  // Declare statements create a new variable similar to how it is done outside
  // the function body. The difference between locals and globals are that:
  // - locals have declaration order,
  // - cannot be used before they are declared,
  // - can have initial values that are unknown in compile-time,
  // - they have lexical scopes,
  // - cannot be used outside the scope they are declared in.
  // - can shadow (have the same name as) global symbols,
  var variable int = add(67, 17 * 58);



  // Affect Statement
  // ----------------

  // Affect statements are only executed for their side-effects. They mutate a
  // variable or call a function.

  // Discard statements evaluate an expression, but do not use the result.
  do_it();

  // Mutate statements change a variable's value using a trailing `++` or `--`.
  variable++; // add 1
  variable--; // subtract 1

  // Assign statements override a variable's value using a `=` and a value.
  variable = 90; // assign 90

  // The assignment can be compounded with an arithmetic binary operator to do
  // the binary operation on the assignee's previous value.
  variable  *= 10; // multiplies by 10
  variable  /= 10; // assigns the quotient of division by 10
  variable  %= 10; // assigns the reminder of division by 10
  variable  += 10; // adds 10
  variable  -= 10; // subtracts 10
  variable <<= 10; // shifts its bits to left by 10
  variable >>= 10; // shifts its bits to right by 10
  variable  &= 10; // ANDs its bits with bits of 10
  variable  ^= 10; // XORs its bits with bits of 10
  variable  |= 10; // ORs its bits with bits of 10



  // Block Statement
  // ---------------

  // Block statements group zero or more statements together and create a
  // lexical scope which restricts the locals.
  {
    17 + 58;
    var a int = 17 + 58;
    { var some_local int = 5; }
    { var some_local int = 5; }
    { { { { { { { { {} } } } } } } } }
  }



  // If Statement
  // ------------

  // If statements branch the control flow depending on a condition. The `if`
  // branch is taken if the condition is not zero, otherwise the `else` branch
  // is taken.
  if (variable < 58) { variable *= 2; }
  else { variable -= 5; }

  // The `else` branch can be omitted, which is the same as it having an empty
  // block as the body.
  if (17 < variable) { variable <<= 2; }

  // Any amount of declare and affect statements leading the condition. Such are
  // executed as if the `if` was in a block and these statements were just above
  // the `if` in the block.
  if (variable += 10; variable < 17) { variable <<= 2; }
  if (var a int = variable * 2; a < 17) { variable += a; }
  else { variable -= a; }



  // For Statement
  // -------------

  // For statements loop the control flow depending on a condition. In the first
  // iteration, the `for` branch is taken if the condition is not zero,
  // otherwise the `else` branch is taken. After the `for` branch is taken once,
  // it is taken many times until the condition is revaluated to zero.
  {
    var sum int = 0;
    var n   int = 1;
    for (n <= 10) { n++; sum += n; }
    else { sum = -1; }
  }

  // The `else` branch can be omitted, which is the same as it having an empty
  // block as the body.
  {
    var pre_leading int = 0;
    var leading     int = 1;
    var fib         int = 1;
    var n           int = 1;
    for (n <= 10) {
      n++;
      pre_leading = leading;
      leading = fib;
      fib += pre_leading;
    }
  }

  // An affect statement trailing the loop condition can be provided, which will
  // be executed between iterations.
  var fib int = 0;
  {
    fib = 1;
    var pre_leading int = 0;
    var leading     int = 1;
    var n           int = 1;
    for (n <= 10; n++) {
      pre_leading = leading;
      leading = fib;
      fib += pre_leading;
    }
  }

  // Any amount of declare and affect statements leading the condition. Such are
  // executed as if the `for` was in a block and these statements were just
  // above the `for` in the block.
  for (
    fib = 1;
    var pre_leading int = 0;
    var leading     int = 1;
    var n           int = 1;
    n <= 10; n++)
  {
    pre_leading = leading;
    leading = fib;
    fib += pre_leading;
  }



  // Break Statement
  // ---------------

  // Used for jumping out of a loop before it terminates by its condition.
  for (var i int = 0; i < 10; i++) {
    if (i == 5) { break; }
  }

  // Takes a label to specify which loop to break.
  {
    var sum     int = 0;
    var max_sum int = 17;
    combinations: for(var i int = 0; i < 10; i++) {
      for(var j int = i + 1; j < 10; j++) {
        var combination int = i * 10 + j;
        if (sum > max_sum - combination) { break combinations; }
        sum += combination;
      }
    }
  }



  // Continue Statement
  // ------------------

  // Used for jumping back to a loop condition before it executes all statements
  // in the body.
  {
    var odds int = 0;
    for (var i int = 0; i < 10; i++) {
      if (i % 2 == 0) { continue; }
      odds += i;
    }
  }

  // Takes a label to specify which loop to continue.
  {
    var black_squares int = 0;
    horizontal: for(var x int = 0; x < 10; x++) {
      vertical: for(var y int = 0; y < 10; y++) {
        if (is_even(x + y)) { continue horizontal; }
        black_squares++;
      }
    }
  }

  // Return Statement
  // ----------------

  // Terminates a function.
  return;
}

// Functions with return type `duru::void` can reach to the end without a return
// statement. Such functions terminate as if there was an invisible return
// statement at the end.
fn does_not_return() duru::void {}

fn is_even(num int) duru::bool {
  // Functions that a non-`duru::void` return type must have a return statement
  // terminating all control paths. Furthermore, these return statements must
  // have a value, which will be the value seen by the function's caller.
  return num % 2 == 0;
}





// =============================================================================
//                             E X P R E S S I O N S
// =============================================================================

// Constructs that denote a value when evaluated. All expressions have a type
// that must be known in compile-time, which is the type of the value denoted by
// it. Some expressions denote values that are known in compile-time.



// Constants
// ---------

var string_constant duru::byte* = "Hello, Artisan!";
var number_constant duru::int32 = 1919;



// Compound
// --------

fn a_function() duru::void {
  var function_call  duru::bool    = is_even(15);
  var infix_call     duru::bool    = 15:is_even();
  var grouping       duru::int32   = (56 + 5);
  var cast           duru::float32 = duru::float32{10};
  var initialization person_info   = person_info{age = 5, height = 56};
  var member_access  duru::float32 = initialization.height;
}



// Arithmetic Operations
// ---------------------

var promotion      duru::int32 = +5;
var negation       duru::int32 = -5;

var multiplication duru::int32 = 5 * 5;
var quotient       duru::int32 = 5 / 5;
var reminder       duru::int32 = 5 % 5;

var addition       duru::int32 = 5 + 5;
var subtraction    duru::int32 = 5 - 5;



// Bitwise Operations
// ------------------

var bitwise_not duru::uint32 = ~5;

var shift_left  duru::uint32 = 5 << 5;
var shift_right duru::uint32 = 5 >> 5;

var bitwise_and duru::uint32 = 5  & 5;

var bitwise_xor duru::uint32 = 5  ^ 5;

var bitwise_or  duru::uint32 = 5  | 5;



// Comparison Operations
// ---------------------

var less_than                duru::bool = 5  < 5;
var less_than_or_equal_to    duru::bool = 5 <= 5;
var greater_than             duru::bool = 5  > 5;
var greater_than_or_equal_to duru::bool = 5 >= 5;

var equal_to                 duru::bool = 5 == 5;
var not_equal_to             duru::bool = 5 != 5;



// Logical Operations
// ------------------

var logical_not duru::bool = !0;

var logical_and duru::bool = 1 && 1;

var logical_or  duru::bool = 0 || 1;
